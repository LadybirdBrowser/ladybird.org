---
title: This Month in Ladybird - August 2024
description: ?
date: 2024-08-31
draft: true
---

Hello\!

### Welcoming new sponsors

Ladybird is funded entirely by sponsorships and donations from companies and individuals who care about the open web.

In August, weâ€™ve welcomed the following new sponsors:

- [Ahrefs](https://ahrefs.com/) with $50,000
- [Cling](http://cling.com) with $10,000
- [WorkOS](http://workos.com) with $10,000

### Skia now powers SVG and 2D canvas

We already talked last month about adopting Skia as our default rasterizer for high-performance 2D graphics.

This month, we've expanded our use of Skia beyond just HTML document rendering, and it now powers our `<canvas>` element, as well as SVG content! It also helps us render CSS borders faster and more correctly than before.

We've implemented all this as a set of classes with pluggable backends. This leaves the door open for using other graphics libraries in the future.

The main remaining work here is to enable GPU acceleration for 2D canvas graphics.

### `console.table()`

New contributor Gasim Gasimzada has been making improvements to our `console` API this month.
In particular, we were missing `console.table()`, which produces a table from the data passed in and prints it to the browser console.
At the time of writing, the [spec](https://console.spec.whatwg.org/#table) does not have an algorithm for this function,
so Gasim has [written one](https://github.com/whatwg/console/pull/237) and then implemented it in Ladybird.
Hopefully this algorithm will soon be made an official part of the spec, and help all browsers to behave consistently.

### CSS style values

Each CSS property's value is stored as one or more "style value" classes.
We have many of these, and until recently, they were very freeform and unrelated to any specs.
This month, we started moving these in line with the [CSS Typed OM spec](https://drafts.css-houdini.org/css-typed-om-1),
which defines a way for JavaScript to access styling as objects, instead of just strings.
So far, the main change is that we now store colors in whatever form they were written,
instead of converting them to a 32-bit RGBA value during parsing.
This means that using `calc()` inside a color function (such as `background-color: hsl(calc(15deg * 8) 50% 80%)`)
now finally works, which has been a problem for a long time!

### Retained display list

LibWeb's rendering process is divided into two stages.
The first stage involves building a list of draw commands (display list), and the second is the actual rasterization of the commands visible in the viewport from this list.
Until this month, the display list was built from scratch for each frame repaint.
The time required for building the display list depends on the size of the paintable tree, which caused slow repainting of pages with a lot of content, even though we could rasterize them relatively quickly.

This month, we took the first step towards improving this by reusing the display list across repaints if the only thing that requires invalidation is a scroll offset.
This is implemented by separating the display list into two parts:

- The list of draw commands, where each has an associated "scroll frame id"
- The list of scroll frames, where each frame has an id and scroll offset.

Before repainting, the display list is combined with the scroll offsets from the scroll frames list to produce the final draw commands, ready for rasterization.

| Resource                                                       | Before | After   |
| -------------------------------------------------------------- | ------ | ------- |
| [Zig Documentation](https://ziglang.org/documentation/master/) | 25 FPS | 120 FPS |
| [CSS Grid Layout Module](https://www.w3.org/TR/css-grid-2/)    | 60 FPS | 150 FPS |

### Use HarfBuzz for text layout and RTL support

Text layout is a process that takes a unicode string and available fonts as input and returns a list of positioned glyphs.
Until recently, we used our own basic text layout algorithm, which supported simple scripts like Latin and Cyrillic.
However, this month, BenJilks helped us transition to HarfBuzz and implemented support for the direction attribute.
With these two changes combined, Ladybird is now capable of rendering more complex scripts, such as Hebrew and Arabic.

### Alpha premultiplication

The painting process in Ladybird is responsible for displaying a web page's content to screen, and it needs to handle
many different bitmaps from all kinds of sources. An issue we had was that a partially transparent bitmap, such as a PNG
image or `<canvas>` target, would not blend onto other bitmaps in _quite_ the right way.

When dealing with alpha channels in bitmaps, there are two ways to deal with color data (i.e. the RGB channels): you can
either premultiply the color data with the alpha channel, or you can leave it alone. Premultiplying color data allows
for an optimization during blending, so it's a valid use case. Unfortunately, we were always assuming bitmap data
contains unpremultiplied color data, resulting in all kinds of ugly blending artifacts. On top of that, we didn't even
know what type of color data we were dealing with.

We started tracking the alpha type for each bitmap and now pass along this metadata to the Skia backend, getting rid of
these artifacts once and for all!

### Input selection API

Most text input elements such as `<input type="text">` and `<textarea>` have a DOM API to interact with their selection
state. With properties such as `.selectionStart` and `.selectionEnd` or methods such as `.select()`, you can
programmatically interact with the selection for an element.

Ladybird now implements these APIs almost fully according to spec and keeps the UI selection and element selection state
in sync!

### Web Platform Tests

This month has seen substantial progress on the Web Platform Tests!

We now have a dedicated server that runs the Web Platform Tests nightly. Our results are now published to the main
[wpt.fyi](https//wpt.fyi) dashboard, our latest results can be viewed [here](https://wpt.fyi/results/?product=ladybird).

The Web Platform tests can now be run locally using the `WPT.sh` script. This allows developers to ensure that their
changes don't cause regressions in the Web Platform Tests. The documentation for this script can be found
[here](https://github.com/LadybirdBrowser/ladybird/blob/master/Documentation/RunningTests.md#running-the-web-platform-tests).

WPT compliance has improved significantly this month in a number of areas, particularly our support for multi-byte
legacy text encodings thanks to a PR from BenJilks and our URL parsing support thanks to a series of PRs from
shannonbooth.

We currently pass 214,325 more subtests than this time last month with a total of 930,559 subtests now passing!

### New Security Policy

This month the project adopted a new security policy for reporting vulnerabilities.

In the past, our stance was that the project was pre-alpha and any security vulnerabilities in our code are not
security-critical. Therefore, security vulnerabilities should be treated as regular issues, and reported through our
standard GitHub issue tracker.

However, we've already seen how this policy won't work for us going forward. As we start using more and more open source
libraries, there's a chance that a vulnerability in a third party dependency is critical enough that the security
researchers want to notify all users with a relevant security policy. As we engage more with the wider browser
ecosystem, security researchers who find common vulnerabilities in web specifications, or implementations of web browser
features in other browsers may want to notify all web browsers at once. We have already had one security researcher
contact us with a vulnerability that affected all the other major browser engines, who wanted to ensure that we did not
have the same issue impacting our code.

As we move towards our alpha release, we want to encourage and acknowledge the invaluable service that security
researchers and bug hunters provide to the open source software community. Our new security posture has two main parts:

- We have enabled GitHub's [private vulnerability reporting](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability)
  feature on the main ladybird repository.

- We have drafted a new [SECURITY.md](https://github.com/LadybirdBrowser/ladybird/blob/master/SECURITY.md) file to
  explain our expectations and goals for vulnerability reports

The pre-alpha and work in progress nature of the project means that we don't feel it's the right time to offer bug
bounties for discovered vulnerabilities. However, we will still publish [repository security advisories](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/about-repository-security-advisories)
for valid and in-scope vulnerabilities.

For more details on what we consider in-scope vulnerabilities and our new security policy in general, please see
the [SECURITY.md](https://github.com/LadybirdBrowser/ladybird/blob/master/SECURITY.md) file in our GitHub repository.
We welcome any and all feedback on the policy to help encourage researchers to investigate our code and to clear up
any possibly confusing clauses.

### Adoption of Swift as a C++ Successor Language

We've known for a long time that the future of systems software development involves at least partial adoption of a
memory-safe programming language.

Core contributors have been looking at memory-safe programming languages since as early as the spring of 2022. At that
time, we created a [fork](https://github.com/ADKaster/serenity-rust) of the SerenityOS project that included a rust
toolchain, and experimented with writing rust code to interact with the operating system. This experience didn't spark
as much joy as we'd hoped, and in May of that year, [SophiaJT](https://www.sophiajt.com/) and [Andreas](https://awesomekling.com/)
created the [Jakt](https://github.com/SerenityOS/jakt) programming language to become the "perfect" systems programming
language for the patterns and use case of the SerenityOS project.

However, as time went on it became clear that the project did not have a contributor base excited enough about memory
safe programming language implementation to bring the Jakt programming language to a production-ready status within the
next two years. For SerenityOS project, this is perfectly fine. As explained in the [fork](https://ladybird.org/posts/fork/)
announcement, Ladybird and SerenityOS have different goals and priorities. Unfortunately, the timeline we established
for Ladybird does not align with the slow but steady progress on the Jakt programming language.

Earlier this year, core contributors again started looking at memory safe programming languages to find one that will
meet our needs and be comfortable and productive for our existing contributors. The choice quickly boiled down to two
options: Rust, and Swift. As has already been spoiled by the section title, the language we decided to invest our time
and effort into is Swift.

A lot of consideration has gone into this decision. Swift has both memory and data race safety as of the upcoming Swift
6 release. Swift has strong support for object-oriented programming. While popular discourse tends to dismiss
object-oriented programming as a dated technology, Web specs & browser internals tend to be highly object-oriented, and
life is easier when you can model specs closely in your code.

The Swift team is also investing heavily in C++ interoperability, which means there's a real path to incremental adoption,
not just gigantic rewrites. The approach the Swift team is taking to C++ interoperability allows the Swift frontend to
call directly into the Clang C++ compiler to parse C++ code, and understand it at the AST level, or even lower. Object
passing and data marshalling can be done automatically through the compiler, rather than through unsafe C APIs or other
generated bridge code.

Of course, we won't be hiding in a cave to come out in 6 months with a fully re-written Ladybird codebase entirely in
Swift. A large part of the value proposition of Swift is the incremental adoption story. We are already starting to
experiment with rewrites of small components that handle untrusted input, or could benefit from more parallelism that we
are unwilling to risk with our unsafe C++ patterns. The long tail of C++ isn't going anywhere soon, but we hope that
adopting a memory-safe language as an ergonomic addition to our codebase will help mitigate the kinds of vulnerability
classes that C++ is so famous for.

We're all very excited about the prospect of fearless concurrency, protocol extensions, and seamless C++
interoperability as both Ladybird and Swift mature in the multi-platform space. We're already working with the Swift
team on select issues that will make our adoption smoother.

Look forward to more progress updates on our Swift adoption after the Swift 6 release later this fall.

### Credits

We thank the following people who contributed code to Ladybird in August 2024:

_list,
of,
people_
